<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Introduction to Cypher :: Neo4j Labs Docs</title>
    <link rel="stylesheet" href="../../../_/css/site.css">
  </head>
  <body class="article docs">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="/labs/docs">
        <svg width="97px" height="36px" viewBox="0 0 97 36" class="logo">
          <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
            <g transform="translate(0.000000, 1.000000)" fill-rule="nonzero">
              <g>
                <path
                  d="M28.7331787,15.4086598 C28.7331787,23.4004124 22.3016241,29.8779381 14.3665893,29.8779381 C6.43155452,29.8779381 0,23.4004124 0,15.4086598 C0,7.41690722 6.43155452,0.939375765 14.3665893,0.939375765 C22.3016241,0.932371134 28.7331787,7.41690722 28.7331787,15.4086598"
                  fill="#008CC1"></path>
                <path
                  d="M6.36890951,10.6626804 C6.36890951,11.3006186 5.85382831,11.8193814 5.22041763,11.8193814 C4.58700696,11.8193814 4.07192575,11.3006186 4.07192575,10.6626804 C4.07192575,10.0247423 4.58700696,9.50597938 5.22041763,9.50597938 C5.86078886,9.50597938 6.36890951,10.0247423 6.36890951,10.6626804"
                  fill="#FFFFFF"></path>
                <path
                  d="M6.5638051,13.8383505 C6.5638051,14.4762887 6.0487239,14.9950515 5.41531323,14.9950515 C4.78190255,14.9950515 4.26682135,14.4762887 4.26682135,13.8383505 C4.26682135,13.2004124 4.78190255,12.6816495 5.41531323,12.6816495 C6.0487239,12.6816495 6.5638051,13.1934021 6.5638051,13.8383505"
                  fill="#FFFFFF"></path>
                <path
                  d="M7.26682135,17.203299 C7.26682135,17.8412371 6.75174014,18.36 6.11832947,18.36 C5.48491879,18.36 4.96983759,17.8412371 4.96983759,17.203299 C4.96983759,16.5653608 5.48491879,16.0465979 6.11832947,16.0465979 C6.75174014,16.0395876 7.26682135,16.5583505 7.26682135,17.203299"
                  fill="#FFFFFF"></path>
                <path
                  d="M8.83990719,20.217732 C8.83990719,20.8556701 8.32482599,21.374433 7.69141531,21.374433 C7.05800464,21.374433 6.54292343,20.8556701 6.54292343,20.217732 C6.54292343,19.5797938 7.05800464,19.0610309 7.69141531,19.0610309 C8.32482599,19.0540206 8.83990719,19.5727835 8.83990719,20.217732"
                  fill="#FFFFFF"></path>
                <path
                  d="M21.1392111,24.4309278 C21.1392111,25.068866 20.6241299,25.5876289 19.9907193,25.5876289 C19.3573086,25.5876289 18.8422274,25.068866 18.8422274,24.4309278 C18.8422274,23.7929897 19.3573086,23.2742268 19.9907193,23.2742268 C20.6241299,23.2742268 21.1392111,23.7929897 21.1392111,24.4309278"
                  fill="#FFFFFF"></path>
                <path
                  d="M23.2273782,21.942268 C23.2273782,22.5802062 22.712297,23.0989691 22.0788863,23.0989691 C21.4454756,23.0989691 20.9303944,22.5802062 20.9303944,21.942268 C20.9303944,21.3043299 21.4454756,20.785567 22.0788863,20.785567 C22.712297,20.785567 23.2273782,21.3043299 23.2273782,21.942268"
                  fill="#FFFFFF"></path>
                <path
                  d="M17.1716937,4.34639175 C17.1716937,4.9843299 16.6566125,5.50309278 16.0232019,5.50309278 C15.3897912,5.50309278 14.87471,4.9843299 14.87471,4.34639175 C14.87471,3.70845361 15.3897912,3.18969072 16.0232019,3.18969072 C16.6566125,3.18969072 17.1716937,3.70845361 17.1716937,4.34639175"
                  fill="#FFFFFF"></path>
                <path
                  d="M14.1508121,3.28082474 C14.1508121,3.91876289 13.6357309,4.43752577 13.0023202,4.43752577 C12.3689095,4.43752577 11.8538283,3.91876289 11.8538283,3.28082474 C11.8538283,2.6428866 12.3689095,2.12412371 13.0023202,2.12412371 C13.6357309,2.12412371 14.1508121,2.6428866 14.1508121,3.28082474"
                  fill="#FFFFFF"></path>
                <ellipse id="Oval" stroke="#FFFFFF" fill="#66B245" cx="22.2946636" cy="11.9595876" rx="7.65661253"
                  ry="7.71134021"></ellipse>
                <ellipse id="Oval" stroke="#FFFFFF" fill="#66B245" cx="11.8051044" cy="27.6837113" rx="6.26450116"
                  ry="6.30927835"></ellipse>
                <ellipse id="Oval" stroke="#FFFFFF" fill="#66B245" cx="6.64733179" cy="4.20618557" rx="4.17633411"
                  ry="4.20618557"></ellipse>
              </g>
              <g id="neo4j" transform="translate(33.000000, 1.000000)" fill="#000000">
                <path
                  d="M0,4.87252125 L1.39130435,4.87252125 L1.39130435,7.6203966 C2.05913043,5.9490085 3.45043478,4.64589235 6.28869565,4.64589235 C9.51652174,4.64589235 11.6869565,6.85552408 11.6869565,10.3399433 L11.6869565,19.1501416 L10.2956522,19.1501416 L10.2956522,10.6232295 C10.2956522,7.76203966 8.57043478,5.97733711 5.9826087,5.97733711 C3.17217391,5.97733711 1.39130435,8.18696884 1.39130435,11.4730878 L1.39130435,19.1501416 L0,19.1501416 L0,4.87252125 Z">
                </path>
                <path
                  d="M14.1634783,12.0396601 C14.1634783,7.59206799 17.1408696,4.5325779 21.0086957,4.5325779 C24.8208696,4.5325779 27.52,7.73371105 27.52,11.6430595 C27.52,11.6430595 27.52,12.0679887 27.4921739,12.3512748 L15.5269565,12.3512748 C15.6104348,15.7790368 17.8643478,18.2152975 21.0643478,18.2152975 C23.68,18.2152975 25.4886957,17.082153 26.3234783,16.0056657 L26.3234783,17.6770538 C25.0156522,18.8668555 23.4295652,19.5467422 21.0643478,19.5467422 C17.0295652,19.5467422 14.1634783,16.5439093 14.1634783,12.1246459 L14.1634783,12.0396601 Z M26.0452174,11.0764873 C26.0173913,8.15864023 23.7913043,5.86402266 21.0086957,5.86402266 C18.0869565,5.86402266 15.693913,8.15864023 15.5826087,11.0764873 L26.0452174,11.0764873 Z">
                </path>
                <path
                  d="M37.0643478,4.50424929 C41.1826087,4.50424929 44.4382609,7.70538244 44.4382609,12.0113314 C44.4382609,16.3172805 41.1826087,19.5184136 37.0643478,19.5184136 C32.946087,19.5184136 29.6904348,16.3172805 29.6904348,12.0113314 C29.6904348,7.70538244 32.946087,4.50424929 37.0643478,4.50424929 Z M37.0643478,18.1869688 C40.4869565,18.1869688 43.0469565,15.5240793 43.0469565,12.0113314 C43.0469565,8.49858357 40.4869565,5.83569405 37.0643478,5.83569405 C33.6417391,5.83569405 31.0817391,8.49858357 31.0817391,12.0113314 C31.0817391,15.5240793 33.6417391,18.1869688 37.0643478,18.1869688 Z">
                </path>
                <polygon
                  points="51.7843478 4.87252125 53.3426087 4.87252125 47.3878261 17.7903683 56.0417391 17.7903683 56.0417391 13.1161473 57.4886957 13.1161473 57.4886957 24.6175637 56.0417391 24.6175637 56.0417391 19.1501416 45.1895652 19.1501416">
                </polygon>
                <path
                  d="M62.2469565,4.87252125 L63.6382609,4.87252125 L63.6382609,21.1331445 C63.6382609,24.3342776 61.8295652,24.9858357 60.0765217,24.9858357 C59.7426087,24.9858357 59.3808696,24.9575071 59.1582609,24.9008499 L59.1582609,23.5694051 C59.4921739,23.6260623 59.8817391,23.6543909 60.2156522,23.6543909 C61.6347826,23.6543909 62.2469565,22.9461756 62.2469565,21.1331445 L62.2469565,4.87252125 Z M61.9408696,1.04815864 C61.9408696,0.45325779 62.413913,0.0283286119 62.9426087,0.0283286119 C63.4713043,0.0283286119 63.9443478,0.45325779 63.9443478,1.04815864 C63.9443478,1.61473088 63.4713043,2.03966006 62.9426087,2.03966006 C62.413913,2.03966006 61.9408696,1.61473088 61.9408696,1.04815864 Z">
                </path>
              </g>
            </g>
          </g>
        </svg>

        <svg width="58px" height="34px" viewBox="0 0 58 34">
          <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">

            <path
              d="M7.204,20.364 C10.088,20.364 12.216,18.768 12.804,17.06 L12.804,20 L14.204,20 L14.204,0.484 L12.804,0.484 L12.804,8.828 C12.216,7.12 10.088,5.524 7.204,5.524 C3.256,5.524 0.092,8.688 0.092,12.944 C0.092,17.2 3.228,20.364 7.204,20.364 Z M7.204,19.048 C3.956,19.048 1.492,16.416 1.492,12.944 C1.492,9.5 3.956,6.84 7.204,6.84 C10.48,6.84 12.972,9.388 12.972,12.944 C12.972,16.5 10.48,19.048 7.204,19.048 Z M23.416,20.364 C27.56,20.364 30.836,17.2 30.836,12.944 C30.836,8.688 27.56,5.524 23.416,5.524 C19.272,5.524 15.996,8.688 15.996,12.944 C15.996,17.2 19.272,20.364 23.416,20.364 Z M23.416,19.048 C19.972,19.048 17.396,16.416 17.396,12.944 C17.396,9.472 19.972,6.84 23.416,6.84 C26.86,6.84 29.436,9.472 29.436,12.944 C29.436,16.416 26.86,19.048 23.416,19.048 Z M40.412,20.364 C42.54,20.364 44.416,19.58 45.76,18.152 L44.92,17.2 C43.8,18.376 42.204,19.048 40.412,19.048 C36.968,19.048 34.392,16.416 34.392,12.944 C34.392,9.472 36.968,6.84 40.412,6.84 C42.204,6.84 43.8,7.512 44.92,8.688 L45.76,7.736 C44.416,6.308 42.54,5.524 40.412,5.524 C36.268,5.524 32.992,8.688 32.992,12.944 C32.992,17.2 36.268,20.364 40.412,20.364 Z M52.424,20.308 C55.588,20.308 57.156,18.46 57.156,16.416 C57.156,14.12 55.7,13.084 53.012,11.992 C51.08,11.208 49.792,10.564 49.792,8.996 C49.792,7.68 50.884,6.84 52.312,6.84 C53.572,6.84 54.384,7.372 54.916,8.324 L56.064,7.736 C55.308,6.28 54.02,5.524 52.284,5.524 C50.044,5.524 48.392,6.952 48.392,8.996 C48.392,11.264 49.96,12.16 52.144,13.084 C54.468,14.064 55.756,14.68 55.756,16.416 C55.756,17.676 54.888,18.992 52.424,18.992 C50.212,18.992 48.896,17.9 48.364,16.444 L47.188,16.892 C47.86,19.076 49.848,20.308 52.424,20.308 Z"
              id="docs" fill="#606060" fill-rule="nonzero" id="docs"></path>
          </g>
        </svg>
      </a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">

        <div class="navbar-item is-hoverable developer">
          <a class="navbar-link" href="/developer">Developer Guides</a>
        </div>
        <div class="navbar-item has-dropdown is-hoverable docs">
          <a class="navbar-link" href="/docs">Docs</a>
          <div class="navbar-dropdown">
            <div class="navbar-item project" href="">
              <a class="project-name" href="">Operations Manual</a>

              <ul class="project-links">
                <li><a href="" class="project-link">Migration Guide</a></li>
                <li><a href="" class="project-link">Status Codes</a></li>
              </ul>
            </div>
            <div class="navbar-item project" href="">
              <a class="project-name" href="">Cypher Manual</a>

              <ul class="project-links">
                <li><a href="" class="project-link">Cyper Refcard</a></li>
              </ul>
            </div>
            <div class="navbar-item project" href="">
              <a class="project-name" href="">Driver Manual</a>

              <ul class="project-links">
                <li><a href="" class="project-link">Java</a></li>
                <li><a href="" class="project-link">JavaScript</a></li>
                <li><a href="" class="project-link">.NET</a></li>
                <li><a href="" class="project-link">Python</a></li>
              </ul>
            </div>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable labs">
          <a class="navbar-link" href="/labs">Labs</a>
          <div class="navbar-dropdown">
            <div class="navbar-item project">
              <a class="project-name" href="/labs/apoc">APOC</a>
              <p class="project-description">A library of procedures and functions for interacting with Neo4j</p>

              <ul class="project-links">
                <li><a href="/labs/apoc/4.0" class="project-link">Documentation</a></li>
                <li><a href="/labs/apoc/" class="project-link">Developer Guide</a></li>
              </ul>
            </div>
            <div class="navbar-item project">
              <a class="project-name" href="/labs/streams">Neo4j Streams</a>
              <p class="project-description">Integration for Neo4j &amp; Kafka</p>

              <ul class="project-links">
                <li><a href="/labs/streams/4.0" class="project-link">Documentation</a></li>
                <li><a href="/labs/streams" class="project-link">Developer Guide</a></li>
              </ul>
            </div>
            <div class="navbar-item project">
              <a class="project-name" href="/labs/neosemantics">neosemantics</a>
              <p class="project-description">An RDF Toolkit for Neo4j</p>

              <ul class="project-links">
                <li><a href="/labs/neosemantics/4.0" class="project-link">Documentation</a></li>
                <li><a href="/labs/neosemantics" class="project-link">Developer Guide</a></li>
              </ul>
            </div>
          </div>
        </div>
        <div class="navbar-item">
          <a class="navbar-link" href="/search" id="search_open"><svg width="23px" height="23px" viewBox="0 0 23 23" version="1.1" xmlns="http://www.w3.org/2000/svg"
              xmlns:xlink="http://www.w3.org/1999/xlink" class="fill-current float-right" id="search" role="button"
              title="Search Website">
              <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round"
                stroke-linejoin="round">
                <g transform="translate(-2.000000, -2.000000)" stroke="#a0aec0" stroke-width="1.5">
                  <circle id="Oval"
                    transform="translate(11.389364, 11.388564) rotate(-23.025000) translate(-11.389364, -11.388564) "
                    cx="11.3893642" cy="11.3885639" r="8.056"></circle>
                  <path d="M17.0853333,17.0844444 L23.3333333,23.3333333" id="Shape"></path>
                </g>
              </g>
            </svg><span class="navbar-mobile">Search</span></a>
        </div>
      </div>
    </div>
  </nav>
</header><div class="search" id="search">
    <div class="search-container">
        <form class="search-form">
            <label for="search_input">Search Neo4j.com</label>

            <input id="search_input" type="text" name="search"
                placeholder="Try &quot;MATCH clause&quot; or &quot;Monitoring Queries&quot;">
            <div class="search-icon">
                <svg width="16px" height="22px" viewBox="0 0 23 23" version="1.1" xmlns="http://www.w3.org/2000/svg"
                    xmlns:xlink="http://www.w3.org/1999/xlink" class="fill-current float-right" id="submit_search"
                    role="button" title="Search Website">
                    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round"
                        stroke-linejoin="round">
                        <g transform="translate(-2.000000, -2.000000)" stroke="#a0aec0" stroke-width="1.5">
                            <circle id="Oval"
                                transform="translate(11.389364, 11.388564) rotate(-23.025000) translate(-11.389364, -11.388564) "
                                cx="11.3893642" cy="11.3885639" r="8.056"></circle>
                            <path d="M17.0853333,17.0844444 L23.3333333,23.3333333" id="Shape"></path>
                        </g>
                    </g>
                </svg>
            </div>
            <div class="search-icon">
                <svg width="14px" height="22px" viewBox="0 0 22 22" role="button" class="cancel" id="close_search">
                    <line x1="19.5833333" y1="0.416666667" x2="0.416666667" y2="19.5833333"></line>
                    <line x1="19.5833333" y1="19.5833333" x2="0.416666667" y2="0.416666667"></line>
                </svg>
            </div>
        </form>
        <div class="search-results"></div>

        <div class="search-filters hidden">
            <div class="search-filters-header">
                <h2>Filter By Category</h2>
                <div class="search-filters-icon">
                    <svg width="14px" height="22px" viewBox="0 0 22 22" role="button" class="cancel" id="close_filters">
                        <line x1="19.5833333" y1="0.416666667" x2="0.416666667" y2="19.5833333"></line>
                        <line x1="19.5833333" y1="19.5833333" x2="0.416666667" y2="0.416666667"></line>
                    </svg>
                </div>
            </div>

            <div class="search-filters-content">
            </div>
        </div>

    </div>
</div><div class="body">
<div class="nav-container" data-component="getting-started" data-version="4.0">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Getting Started</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../index.html">The Neo4j Getting Started Guide v4.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../get-started-with-neo4j.html">Get started with Neo4j</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../get-started-with-neo4j.html#_installing_neo4j">Installing Neo4j</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../get-started-with-neo4j.html#_documentation_guide">Documentation guide</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../graphdb-concepts.html">Graph Database Concepts</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../graphdb-concepts.html#graphdb-example-graph">Example Graph</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../graphdb-concepts.html#graphdb-nodes">Nodes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../graphdb-concepts.html#graphdb-labels">Labels</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../graphdb-concepts.html#graphdb-relationships">Relationships</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../graphdb-concepts.html#graphdb-relationship-types">Relationship Types</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../graphdb-concepts.html#graphdb-properties">Properties</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../graphdb-concepts.html#graphdb-traversal">Traversals and Paths</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../graphdb-concepts.html#graphdb-schema">Schema</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../graphdb-concepts.html#graphdb-naming-rules-and-recommendations">Naming Rules and Recommendations</a>
  </li>
</ul>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="index.html">Cypher</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="patterns.html">Patterns</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="patterns-in-practice.html">Patterns in practice</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="results.html">Getting the correct results</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="compose-statements.html">Composing large statements</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="schema.html">Defining a schema</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="load-csv.html">Import data</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Getting Started</a></li>
    <li><a href="index.html">Cypher</a></li>
  </ul>
</nav>
<div class="page-versions">
  <button class="version-menu-toggle" title="Show other versions of page">4.0</button>
  <div class="version-menu">
    <a class="version" href="../../current/cypher-intro/index.html">current</a>
    <a class="version is-current" href="index.html">4.0</a>
  </div>
</div>
  <div class="edit-this-page"><a href="https://github.com/neo-technology/neo4j-manual-modeling-antora/edit/4.0/gettingStarted/modules/ROOT/pages/cypher-intro/index.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<article class="doc">
<h1 class="page">Introduction to Cypher</h1>
<div id="preamble">
<div class="sectionbody">
<div class="quoteblock abstract">
<blockquote>
<div class="paragraph">
<p>This chapter gives a high-level overview of the graph query language Cypher.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>This chapter will introduce you to the graph query language Cypher.
It will help you start thinking about graphs and patterns, apply this knowledge to simple problems, and learn how to write Cypher statements</p>
</div>
<div class="paragraph">
<p>This chapter includes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#cypher-intro-patterns">Patterns</a></p>
<div class="ulist">
<ul>
<li>
<p><a href="#cypher-intro-patterns-node-syntax">Node syntax</a></p>
</li>
<li>
<p><a href="#cypher-intro-patterns-relationship-syntax">Relationship syntax</a></p>
</li>
<li>
<p><a href="#cypher-intro-patterns-pattern-syntax">Pattern syntax</a></p>
</li>
<li>
<p><a href="#cypher-intro-patterns-pattern-variables">Pattern variables</a></p>
</li>
<li>
<p><a href="#cypher-intro-patterns-clauses">Clauses</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="#cypher-intro-patterns-in-practice">Patterns in practice</a></p>
<div class="ulist">
<ul>
<li>
<p><a href="#cypher-intro-patterns-in-practice-creating-data">Creating data</a></p>
</li>
<li>
<p><a href="#cypher-intro-patterns-in-practice-matching-patterns">Matching patterns</a></p>
</li>
<li>
<p><a href="#cypher-intro-patterns-in-practice-attaching-structures">Attaching structures</a></p>
</li>
<li>
<p><a href="#cypher-intro-patterns-in-practice-completing-patterns">Completing patterns</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="#cypher-intro-results">Getting the correct results</a></p>
<div class="ulist">
<ul>
<li>
<p><a href="#cypher-intro-results-filtering">Filtering results</a></p>
</li>
<li>
<p><a href="#cypher-intro-results-returning">Returning results</a></p>
</li>
<li>
<p><a href="#cypher-intro-results-aggregating">Aggregating information</a></p>
</li>
<li>
<p><a href="#cypher-intro-results-ordering-and-pagination">Ordering and pagination</a></p>
</li>
<li>
<p><a href="#cypher-intro-results-collecting-aggregation">Collecting aggregation</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="#cypher-intro-large-statements">Composing large statements</a></p>
<div class="ulist">
<ul>
<li>
<p><a href="#cypher-intro-large-statements-union">UNION</a></p>
</li>
<li>
<p><a href="#cypher-intro-large-statements-with">WITH</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="#cypher-intro-schema">Defining a schema</a></p>
<div class="ulist">
<ul>
<li>
<p><a href="#cypher-intro-schema">Using indexes</a></p>
</li>
<li>
<p><a href="#cypher-intro-schema">Using constraints</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="#cypher-intro-load-csv">Import data</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For a comprehensive guide to Cypher, see the <a href="#cypher-manual.adoc#cypher-manual" class="page unresolved">Cypher manual</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cypher-intro-patterns"><a class="anchor" href="#cypher-intro-patterns"></a>Patterns</h2>
<div class="sectionbody">
<div class="quoteblock abstract">
<blockquote>
<div class="paragraph">
<p>This section gives an introduction to the concept of patterns.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>This section includes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#cypher-intro-patterns-node-syntax">Node syntax</a></p>
</li>
<li>
<p><a href="#cypher-intro-patterns-relationship-syntax">Relationship syntax</a></p>
</li>
<li>
<p><a href="#cypher-intro-patterns-pattern-syntax">Pattern syntax</a></p>
</li>
<li>
<p><a href="#cypher-intro-patterns-pattern-variables">Pattern variables</a></p>
</li>
<li>
<p><a href="#cypher-intro-patterns-clauses">Clauses</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Neo4j&#8217;s Property Graphs are composed of nodes and relationships, either of which may have properties.
Nodes represent entities, for example concepts, events, places and things.
Relationships connect pairs of nodes.</p>
</div>
<div class="paragraph">
<p>However, nodes and relationships can be considered as low-level building blocks.
The real strength of the property graph lies in its ability to encode <em>patterns</em> of connected nodes and relationships.
A single node or relationship typically encodes very little information,
but a pattern of nodes and relationships can encode arbitrarily complex ideas.</p>
</div>
<div class="paragraph">
<p>Cypher, Neo4j&#8217;s query language, is strongly based on patterns.
Specifically, patterns are used to match desired graph structures.
Once a matching structure has been found or created, Neo4j can use it for further processing.</p>
</div>
<div class="paragraph">
<p>A simple pattern, which has only a single relationship, connects a pair of nodes (or, occasionally, a node to itself).
For example, <em>a Person</em> <code>LIVES_IN</code> <em>a City</em> or <em>a City is</em> <code>PART_OF</code> <em>a Country</em>.</p>
</div>
<div class="paragraph">
<p>Complex patterns, using multiple relationships, can express arbitrarily complex concepts and support a variety of interesting use cases.
For example, we might want to match instances where <em>a Person</em>  <code>LIVES_IN</code> <em>a Country</em>.
The following Cypher code combines two simple patterns into a slightly more complex pattern which performs this match:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">(:Person) -[:LIVES_IN]-&gt; (:City) -[:PART_OF]-&gt; (:Country)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Diagrams made up of icons and arrows are commonly used to visualize graphs.
Textual annotations provide labels, define properties etc.</p>
</div>
<div class="sect2">
<h3 id="cypher-intro-patterns-node-syntax"><a class="anchor" href="#cypher-intro-patterns-node-syntax"></a>Node syntax</h3>
<div class="paragraph">
<p>Cypher uses a pair of parentheses to represent a node: <code>()</code>.
This is reminiscent of a circle or a rectangle with rounded end caps.
Below are some examples of nodes, providing varying types and amounts of detail:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">()
(matrix)
(:Movie)
(matrix:Movie)
(matrix:Movie {title: "The Matrix"})
(matrix:Movie {title: "The Matrix", released: 1997})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The simplest form, <code>()</code>, represents an anonymous, uncharacterized node.
If we want to refer to the node elsewhere, we can add a variable, for example: <code>(matrix)</code>.
A variable is restricted to a single statement.
It may have different or no meaning in another statement.</p>
</div>
<div class="paragraph">
<p>The <code>:Movie</code> pattern declares a label of the node.
This allows us to restricts the pattern, keeping it from matching (say) a structure with an <code>Actor</code> node in this position.</p>
</div>
<div class="paragraph">
<p>The node&#8217;s properties, for example <code>title</code>, are represented as a list of key/value pairs, enclosed within a pair of braces, for example: <code>{name:  "Keanu Reeves"}</code>.
Properties can be used to store information and/or restrict patterns.</p>
</div>
</div>
<div class="sect2">
<h3 id="cypher-intro-patterns-relationship-syntax"><a class="anchor" href="#cypher-intro-patterns-relationship-syntax"></a>Relationship syntax</h3>
<div class="paragraph">
<p>Cypher uses a pair of dashes (<code>--</code>) to represent an undirected relationship.
Directed relationships have an arrowhead at one end (<code>&lt;--</code>, <code>--&gt;</code>).
Bracketed expressions (<code>[&#8230;&#8203;]</code>) can be used to add details.
This may include variables, properties, and type information:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">--&gt;
-[role]-&gt;
-[:ACTED_IN]-&gt;
-[role:ACTED_IN]-&gt;
-[role:ACTED_IN {roles: ["Neo"]}]-&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The syntax and semantics found within a relationship&#8217;s bracket pair are very similar to those used between a node&#8217;s parentheses.
A variable (eg, <code>role</code>) can be defined, to be used elsewhere in the statement.
The relationship&#8217;s type (eg, <code>:ACTED_IN</code>) is analogous to the node&#8217;s label.
The properties (eg, <code>roles</code>) are entirely equivalent to node properties.</p>
</div>
</div>
<div class="sect2">
<h3 id="cypher-intro-patterns-pattern-syntax"><a class="anchor" href="#cypher-intro-patterns-pattern-syntax"></a>Pattern syntax</h3>
<div class="paragraph">
<p>Combining the syntax for nodes and relationships, we can express patterns.
The following could be a simple pattern (or fact) in this domain:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">(keanu:Person:Actor {name:  "Keanu Reeves"} )
-[role:ACTED_IN     {roles: ["Neo"] } ]-&gt;
(matrix:Movie       {title: "The Matrix"} )</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to node labels, the <code>:ACTED_IN</code> pattern declares the relationship type of the relationship.
Variables (eg, <code>role</code>) can be used elsewhere in the statement to refer to the relationship.</p>
</div>
<div class="paragraph">
<p>As with node properties, relationship properties are represented as a list of key/value pairs enclosed within a pair of braces, for example: <code>{roles: ["Neo"]}</code>.
In this case, we used an array property for the <code>roles</code>, allowing multiple roles to be specified.
Properties can be used to store information and/or restrict patterns.</p>
</div>
</div>
<div class="sect2">
<h3 id="cypher-intro-patterns-pattern-variables"><a class="anchor" href="#cypher-intro-patterns-pattern-variables"></a>Pattern variables</h3>
<div class="paragraph">
<p>To increase modularity and reduce repetition, Cypher allows patterns to be assigned to variables.
This allows the matching paths to be inspected, used in other expressions, etc.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">acted_in = (:Person)-[:ACTED_IN]-&gt;(:Movie)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>acted_in</code> variable would contain two nodes and the connecting relationship for each path that was found or created.
There are a number of functions to access details of a path, for example: <code>nodes(path)</code>, <code>relationships(path)</code> and <code>length(path)</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="cypher-intro-patterns-clauses"><a class="anchor" href="#cypher-intro-patterns-clauses"></a>Clauses</h3>
<div class="paragraph">
<p>Cypher statements typically have multiple <em>clauses</em>, each of which performs a specific task, for example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>create and match patterns in the graph</p>
</li>
<li>
<p>filter, project, sort, or paginate results</p>
</li>
<li>
<p>compose partial statements</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By combining Cypher clauses, we can compose more complex statements that express what we want to know or create.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cypher-intro-patterns-in-practice"><a class="anchor" href="#cypher-intro-patterns-in-practice"></a>Patterns in practice</h2>
<div class="sectionbody">
<div class="quoteblock abstract">
<blockquote>
<div class="paragraph">
<p>This section describes how patterns are used in practice</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>This section includes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#cypher-intro-patterns-in-practice-creating-data">Creating data</a></p>
</li>
<li>
<p><a href="#cypher-intro-patterns-in-practice-matching-patterns">Matching patterns</a></p>
</li>
<li>
<p><a href="#cypher-intro-patterns-in-practice-attaching-structures">Attaching structures</a></p>
</li>
<li>
<p><a href="#cypher-intro-patterns-in-practice-completing-patterns">Completing patterns</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="cypher-intro-patterns-in-practice-creating-data"><a class="anchor" href="#cypher-intro-patterns-in-practice-creating-data"></a>Creating data</h3>
<div class="paragraph">
<p>We&#8217;ll start by looking into the clauses that allow us to create data.</p>
</div>
<div class="paragraph">
<p>To add data, we just use the patterns we already know.
By providing patterns we can specify what graph structures, labels and properties we would like to make part of our graph.</p>
</div>
<div class="paragraph">
<p>Obviously the simplest clause is called <code>CREATE</code>.
It will just go ahead and directly create the patterns that you specify.</p>
</div>
<div class="paragraph">
<p>For the patterns we&#8217;ve looked at so far this could look like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">CREATE (:Movie { title:"The Matrix",released:1997 })</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we execute this statement, Cypher returns the number of changes, in this case adding 1 node, 1 label and 2 properties.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>+-------------------+
| No data returned. |
+-------------------+
Nodes created: 1
Properties set: 2
Labels added: 1</pre>
</div>
</div>
<div class="paragraph">
<p>As we started out with an empty database, we now have a database with a single node in it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  N0 [
    label = "{Movie|title = \'The Matrix\'\lreleased = 1997\l}"
  ]</pre>
</div>
</div>
<div class="paragraph">
<p>If case we also want to return the created data we can add a <code>RETURN</code> clause, which refers to the variable we&#8217;ve assigned to our pattern elements.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">CREATE (p:Person { name:"Keanu Reeves", born:1964 })
RETURN p</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is what gets returned:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>+----------------------------------------+
| p                                      |
+----------------------------------------+
| Node[1]{name:"Keanu Reeves",born:1964} |
+----------------------------------------+
1 row
Nodes created: 1
Properties set: 2
Labels added: 1</pre>
</div>
</div>
<div class="paragraph">
<p>If we want to create more than one element, we can separate the elements with commas or use multiple <code>CREATE</code> statements.</p>
</div>
<div class="paragraph">
<p>We can of course also create more complex structures, like an <code>ACTED_IN</code> relationship with information about the character, or <code>DIRECTED</code> ones for the director.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">CREATE (a:Person { name:"Tom Hanks",
  born:1956 })-[r:ACTED_IN { roles: ["Forrest"]}]-&gt;(m:Movie { title:"Forrest Gump",released:1994 })
CREATE (d:Person { name:"Robert Zemeckis", born:1951 })-[:DIRECTED]-&gt;(m)
RETURN a,d,r,m</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the part of the graph we just updated:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  N2 [
    label = "{Person|name = \'Tom Hanks\'\lborn = 1956\l}"
  ]
  N2 -&gt; N3 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nroles = \[\'Forrest\'\]\l"
  ]
  N3 [
    label = "{Movie|title = \'Forrest Gump\'\lreleased = 1994\l}"
  ]
  N4 -&gt; N3 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "DIRECTED\n"
  ]
  N4 [
    label = "{Person|name = \'Robert Zemeckis\'\lborn = 1951\l}"
  ]</pre>
</div>
</div>
<div class="paragraph">
<p>In most cases, we want to connect new data to existing structures.
This requires that we know how to find existing patterns in our graph data, which we will look at next.</p>
</div>
</div>
<div class="sect2">
<h3 id="cypher-intro-patterns-in-practice-matching-patterns"><a class="anchor" href="#cypher-intro-patterns-in-practice-matching-patterns"></a>Matching patterns</h3>
<div class="paragraph">
<p>Matching patterns is a task for the <code>MATCH</code> statement.
We pass the same kind of patterns we&#8217;ve used so far to <code>MATCH</code> to describe what we&#8217;re looking for.
It is similar to <em>query by example</em>, only that our examples also include the structures.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A <code>MATCH</code> statement will search for the patterns we specify and return <em>one row per successful pattern match</em>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To find the data we&#8217;ve created so far, we can start looking for all nodes labeled with the <code>Movie</code> label.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">MATCH (m:Movie)
RETURN m</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s the result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  N0 [
    label = "{Movie|title = \'The Matrix\'\lreleased = 1997\l}"
  ]
  N1 [
    label = "{Movie|title = \'Forrest Gump\'\lreleased = 1994\l}"
  ]</pre>
</div>
</div>
<div class="paragraph">
<p>This should show both <em>The Matrix</em> and <em>Forrest Gump</em>.</p>
</div>
<div class="paragraph">
<p>We can also look for a specific person, like <em>Keanu Reeves</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">MATCH (p:Person { name:"Keanu Reeves" })
RETURN p</code></pre>
</div>
</div>
<div class="paragraph">
<p>This query returns the matching node:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  N0 [
    label = "{Person|name = \'Keanu Reeves\'\lborn = 1964\l}"
  ]</pre>
</div>
</div>
<div class="paragraph">
<p>Note that we only provide enough information to find the nodes, not all properties are required.
In most cases you have key-properties like SSN, ISBN, emails, logins, geolocation or product codes to look for.</p>
</div>
<div class="paragraph">
<p>We can also find more interesting connections, like for instance the movies titles that <em>Tom Hanks</em> acted in and the roles he played.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">MATCH (p:Person { name:"Tom Hanks" })-[r:ACTED_IN]-&gt;(m:Movie)
RETURN m.title, r.roles</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>+------------------------------+
| m.title        | r.roles     |
+------------------------------+
| "Forrest Gump" | ["Forrest"] |
+------------------------------+
1 row</pre>
</div>
</div>
<div class="paragraph">
<p>In this case we only returned the properties of the nodes and relationships that we were interested in.
You can access them everywhere via a dot notation <code>identifer.property</code>.</p>
</div>
<div class="paragraph">
<p>Of course this only lists his role as <em>Forrest</em> in <em>Forrest Gump</em> because that&#8217;s all data that we&#8217;ve added.</p>
</div>
<div class="paragraph">
<p>Now we know enough to connect new nodes to existing ones and can combine <code>MATCH</code> and <code>CREATE</code> to attach structures to the graph.</p>
</div>
</div>
<div class="sect2">
<h3 id="cypher-intro-patterns-in-practice-attaching-structures"><a class="anchor" href="#cypher-intro-patterns-in-practice-attaching-structures"></a>Attaching structures</h3>
<div class="paragraph">
<p>To extend the graph with new information, we first match the existing connection points and then attach the newly created nodes to them with relationships.
Adding <em>Cloud Atlas</em> as a new movie for <em>Tom Hanks</em> could be achieved like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">MATCH (p:Person { name:"Tom Hanks" })
CREATE (m:Movie { title:"Cloud Atlas",released:2012 })
CREATE (p)-[r:ACTED_IN { roles: ['Zachry']}]-&gt;(m)
RETURN p,r,m</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s what the structure looks like in the database:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  N2 [
    label = "{Person|name = \'Tom Hanks\'\lborn = 1956\l}"
  ]
  N2 -&gt; N5 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nroles = \[\'Zachry\'\]\l"
  ]
  N5 [
    label = "{Movie|title = \'Cloud Atlas\'\lreleased = 2012\l}"
  ]</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
It is important to remember that we can assign variables to both nodes and relationships and use them later on, no matter if they were created or matched.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is possible to attach both node and relationship in a single <code>CREATE</code> clause.
For readability it helps to split them up though.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
A tricky aspect of the combination of <code>MATCH</code> and <code>CREATE</code> is that we get <em>one row per matched pattern</em>.
This causes subsequent <code>CREATE</code> statements to be executed once for each row.
In many cases this is what you want.
If that&#8217;s not intended, please move the <code>CREATE</code> statement before the <code>MATCH</code>, or change the cardinality of the query with means discussed later or use the <em>get or create</em> semantics of the next clause: <code>MERGE</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="cypher-intro-patterns-in-practice-completing-patterns"><a class="anchor" href="#cypher-intro-patterns-in-practice-completing-patterns"></a>Completing patterns</h3>
<div class="paragraph">
<p>Whenever we get data from external systems or are not sure if certain information already exists in the graph, we want to be able to express a repeatable (idempotent) update operation.
In Cypher <code>MERGE</code> has this function.
It acts like a combination of <code>MATCH</code> <em>or</em> <code>CREATE</code>, which checks for the existence of data first before creating it.
With <code>MERGE</code> you define a pattern to be found or created.
Usually, as with <code>MATCH</code> you only want to include the key property to look for in your core pattern.
<code>MERGE</code> allows you to provide additional properties you want to set <code>ON CREATE</code>.</p>
</div>
<div class="paragraph">
<p>If we wouldn&#8217;t know if our graph already contained <em>Cloud Atlas</em> we could merge it in again.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">MERGE (m:Movie { title:"Cloud Atlas" })
ON CREATE SET m.released = 2012
RETURN m</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>+--------------------------------------------+
| m                                          |
+--------------------------------------------+
| Node[5]{title:"Cloud Atlas",released:2012} |
+--------------------------------------------+
1 row</pre>
</div>
</div>
<div class="paragraph">
<p>We get a result in any both cases: either the data (potentially more than one row) that was already in the graph or a single, newly created <code>Movie</code> node.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A <code>MERGE</code> clause without any previously assigned variables in it either matches the full pattern or creates the full pattern.
It never produces a partial mix of matching and creating within a pattern.
To achieve a partial match/create, make sure to use already defined variables for the parts that shouldn&#8217;t be affected.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>So foremost <code>MERGE</code> makes sure that you can&#8217;t create duplicate information or structures, but it comes with the cost of needing to check for existing matches first.
Especially on large graphs it can be costly to scan a large set of labeled nodes for a certain property.
You can alleviate some of that by creating supporting indexes or constraints, which we&#8217;ll discuss later.
But it&#8217;s still not for free, so whenever you&#8217;re sure to not create duplicate data use <code>CREATE</code> over <code>MERGE</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>MERGE</code> can also assert that a relationship is only created once.
For that to work you <em>have to pass in</em> both nodes from a previous pattern match.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">MATCH (m:Movie { title:"Cloud Atlas" })
MATCH (p:Person { name:"Tom Hanks" })
MERGE (p)-[r:ACTED_IN]-&gt;(m)
ON CREATE SET r.roles =['Zachry']
RETURN p,r,m</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>  N2 [
    label = "{Person|name = \'Tom Hanks\'\lborn = 1956\l}"
  ]
  N2 -&gt; N5 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nroles = \[\'Zachry\'\]\l"
  ]
  N5 [
    label = "{Movie|title = \'Cloud Atlas\'\lreleased = 2012\l}"
  ]</pre>
</div>
</div>
<div class="paragraph">
<p>In case the direction of a relationship is arbitrary, you can leave off the arrowhead.
<code>MERGE</code> will then check for the relationship in either direction, and create a new directed relationship if no matching relationship was found.</p>
</div>
<div class="paragraph">
<p>If you choose to pass in only one node from a preceding clause, <code>MERGE</code> offers an interesting functionality.
It will then only match within the direct neighborhood of the provided node for the given pattern, and, if not found create it.
This can come in very handy for creating for example tree structures.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">CREATE (y:Year { year:2014 })
MERGE (y)&lt;-[:IN_YEAR]-(m10:Month { month:10 })
MERGE (y)&lt;-[:IN_YEAR]-(m11:Month { month:11 })
RETURN y,m10,m11</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the graph structure that gets created:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  N6 [
    label = "{Year|year = 2014\l}"
  ]
  N8 -&gt; N6 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "IN_YEAR\n"
  ]
  N7 -&gt; N6 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "IN_YEAR\n"
  ]
  N7 [
    label = "{Month|month = 10\l}"
  ]
  N8 [
    label = "{Month|month = 11\l}"
  ]</pre>
</div>
</div>
<div class="paragraph">
<p>Here there is no global search for the two <code>Month</code> nodes; they are only searched for in the context of the <em>2014</em> <code>Year</code> node.</p>
</div>
<p class="cypherdoc-console"></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cypher-intro-results"><a class="anchor" href="#cypher-intro-results"></a>Getting the correct results</h2>
<div class="sectionbody">
<div class="quoteblock abstract">
<blockquote>
<div class="paragraph">
<p>This section describes how to manipulate the output of Cypher queries in order to get the results you are looking for.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>This section includes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#cypher-intro-results-example-graph">Example graph</a></p>
</li>
<li>
<p><a href="#cypher-intro-results-filtering">Filtering results</a></p>
</li>
<li>
<p><a href="#cypher-intro-results-returning">Returning results</a></p>
</li>
<li>
<p><a href="#cypher-intro-results-aggregating">Aggregating information</a></p>
</li>
<li>
<p><a href="#cypher-intro-results-ordering-and-pagination">Ordering and pagination</a></p>
</li>
<li>
<p><a href="#cypher-intro-results-collecting-aggregation">Collecting aggregation</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="cypher-intro-results-example-graph"><a class="anchor" href="#cypher-intro-results-example-graph"></a>Example graph</h3>
<div class="paragraph">
<p>First we create some data to use for our examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">CREATE (matrix:Movie { title:"The Matrix",released:1997 })
CREATE (cloudAtlas:Movie { title:"Cloud Atlas",released:2012 })
CREATE (forrestGump:Movie { title:"Forrest Gump",released:1994 })
CREATE (keanu:Person { name:"Keanu Reeves", born:1964 })
CREATE (robert:Person { name:"Robert Zemeckis", born:1951 })
CREATE (tom:Person { name:"Tom Hanks", born:1956 })
CREATE (tom)-[:ACTED_IN { roles: ["Forrest"]}]-&gt;(forrestGump)
CREATE (tom)-[:ACTED_IN { roles: ['Zachry']}]-&gt;(cloudAtlas)
CREATE (robert)-[:DIRECTED]-&gt;(forrestGump)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the resulting graph:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  N0 [
    label = "{Movie|title = \'The Matrix\'\lreleased = 1997\l}"
  ]
  N1 [
    label = "{Movie|title = \'Cloud Atlas\'\lreleased = 2012\l}"
  ]
  N2 [
    label = "{Movie|title = \'Forrest Gump\'\lreleased = 1994\l}"
  ]
  N3 [
    label = "{Person|name = \'Keanu Reeves\'\lborn = 1964\l}"
  ]
  N4 [
    label = "{Person|name = \'Robert Zemeckis\'\lborn = 1951\l}"
  ]
  N4 -&gt; N2 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "DIRECTED\n"
  ]
  N5 [
    label = "{Person|name = \'Tom Hanks\'\lborn = 1956\l}"
  ]
  N5 -&gt; N1 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "ACTED_IN\nroles = \[\'Zachry\'\]\l"
  ]
  N5 -&gt; N2 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "ACTED_IN\nroles = \[\'Forrest\'\]\l"
  ]</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cypher-intro-results-filtering"><a class="anchor" href="#cypher-intro-results-filtering"></a>Filtering results</h3>
<div class="paragraph">
<p>So far we have matched patterns in the graph and always returned all results we found.
Now we will look into options for filtering the results and only return the subset of data that we are interested in.
Those filter conditions are expressed using the <code>WHERE</code> clause.
This clause allows to use any number of boolean expressions, <em>predicates</em>, combined with <code>AND</code>, <code>OR</code>, <code>XOR</code> and <code>NOT</code>.
The simplest predicates are comparisons; especially equality.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">MATCH (m:Movie)
WHERE m.title = "The Matrix"
RETURN m</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>+------------------------------------------------+
| m                                              |
+------------------------------------------------+
| (:Movie {title: "The Matrix", released: 1997}) |
+------------------------------------------------+

1 row</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The query above, using the <code>WHERE</code> clause, is equivalent to this query which includes the condition in the pattern matching:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">MATCH (m:Movie { title: "The Matrix" })
RETURN m</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Other options are numeric comparisons, matching regular expressions, and checking the existence of values within a list.</p>
</div>
<div class="paragraph">
<p>The <code>WHERE</code> clause in the following example includes a regular expression match, a greater-than comparison, and a test to see if a value exists in a list:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">MATCH (p:Person)-[r:ACTED_IN]-&gt;(m:Movie)
WHERE p.name =~ "K.+" OR m.released &gt; 2000 OR "Neo" IN r.roles
RETURN p,r,m</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>+-------------------------------------------------------------------------------------------------------------------------------+
| p                                         | r                               | m                                               |
+-------------------------------------------------------------------------------------------------------------------------------+
| (:Person {name: "Tom Hanks", born: 1956}) | [:ACTED_IN {roles: ["Zachry"]}] | (:Movie {title: "Cloud Atlas", released: 2012}) |
+-------------------------------------------------------------------------------------------------------------------------------+

1 row</pre>
</div>
</div>
<div class="paragraph">
<p>An advanced aspect is that patterns can be used as predicates.
Where <code>MATCH</code> expands the number and shape of patterns matched, a pattern predicate restricts the current result set.
It only allows the paths to pass that satisfy the specified pattern.
As we can expect, the use of <code>NOT</code> only allows the paths to pass that do <em>not</em> satisfy the specified pattern.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">MATCH (p:Person)-[:ACTED_IN]-&gt;(m)
WHERE NOT (p)-[:DIRECTED]-&gt;()
RETURN p,m</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>+----------------------------------------------------------------------------------------------+
| p                                         | m                                                |
+----------------------------------------------------------------------------------------------+
| (:Person {name: "Tom Hanks", born: 1956}) | (:Movie {title: "Cloud Atlas", released: 2012})  |
| (:Person {name: "Tom Hanks", born: 1956}) | (:Movie {title: "Forrest Gump", released: 1994}) |
+----------------------------------------------------------------------------------------------+

2 rows</pre>
</div>
</div>
<div class="paragraph">
<p>Here we find actors, because they sport an <code>ACTED_IN</code> relationship but then skip those that ever <code>DIRECTED</code> any movie.</p>
</div>
<div class="paragraph">
<p>There are more advanced ways of filtering, for example <em>list predicates</em>, which we will discuss later in this section.</p>
</div>
</div>
<div class="sect2">
<h3 id="cypher-intro-results-returning"><a class="anchor" href="#cypher-intro-results-returning"></a>Returning results</h3>
<div class="paragraph">
<p>So far, we have returned nodes, relationships and paths directly via their variables.
However, the <code>RETURN</code> clause can return any number of expressions.
But what are expressions in Cypher?</p>
</div>
<div class="paragraph">
<p>The simplest expressions are literal values.
Examples of literal values are: numbers, strings, arrays (for example: <code>[1,2,3]</code>), and maps (for example: <code>{name:"Tom Hanks", born:1964, movies:["Forrest Gump", &#8230;&#8203;], count:13}</code>).
Individual properties of any node, relationship or map can be accessed using the <em>dot syntax</em>, for example: <code>n.name</code>.
Individual elements or slices of arrays can be retrieved with subscripts, for example: <code>names[0]</code> and <code>movies[1..-1]</code>.
Each function evaluation, for example: <code>length(array)</code>, <code>toInteger("12")</code>, <code>substring("2014-07-01",0,4)</code> and <code>coalesce(p.nickname,"n/a")</code>, is also an expression.</p>
</div>
<div class="paragraph">
<p>Predicates used in <code>WHERE</code> clauses count as <em>boolean expressions</em>.</p>
</div>
<div class="paragraph">
<p>Simple expressions can be composed and concatenated to form more complex expressions.</p>
</div>
<div class="paragraph">
<p>By default the expression itself will be used as label for the column, in many cases you want to alias that with a more understandable name using <code>expression AS alias</code>.
The alias can be used subsequently to refer to that column.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">MATCH (p:Person)
RETURN p, p.name AS name, toUpper(p.name), coalesce(p.nickname,"n/a") AS nickname,
  { name: p.name, label:head(labels(p))} AS person</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>+-------------------------------------------------------------------------------------------------------------------------------------------------+
| p                                               | name              | toUpper(p.name)   | nickname | person                                     |
+-------------------------------------------------------------------------------------------------------------------------------------------------+
| (:Person {name: "Keanu Reeves", born: 1964})    | "Keanu Reeves"    | "KEANU REEVES"    | "n/a"    | {name: "Keanu Reeves", label: "Person"}    |
| (:Person {name: "Robert Zemeckis", born: 1951}) | "Robert Zemeckis" | "ROBERT ZEMECKIS" | "n/a"    | {name: "Robert Zemeckis", label: "Person"} |
| (:Person {name: "Tom Hanks", born: 1956})       | "Tom Hanks"       | "TOM HANKS"       | "n/a"    | {name: "Tom Hanks", label: "Person"}       |
+-------------------------------------------------------------------------------------------------------------------------------------------------+

3 rows</pre>
</div>
</div>
<div class="paragraph">
<p>If we wish to display only unique results we can use the <code>DISTINCT</code> keyword after <code>RETURN</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">MATCH (n)
RETURN DISTINCT labels(n) AS Labels</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>+------------+
| Labels     |
+------------+
| ["Movie"]  |
| ["Person"] |
+------------+

2 rows</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cypher-intro-results-aggregating"><a class="anchor" href="#cypher-intro-results-aggregating"></a>Aggregating information</h3>
<div class="paragraph">
<p>In many cases we wish to aggregate or group the data encountered while traversing patterns in our graph.
In Cypher, aggregation happens in the <code>RETURN</code> clause while computing the final results.
Many common aggregation functions are supported, e.g. <code>count</code>, <code>sum</code>, <code>avg</code>, <code>min</code>, and <code>max</code>, but there are several more.</p>
</div>
<div class="paragraph">
<p>Counting the number of people in your database could be achieved by this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">MATCH (:Person)
RETURN count(*) AS people</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>+--------+
| people |
+--------+
| 3      |
+--------+
1 row</pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>NULL</code> values are skipped during aggregation.
For aggregating only unique values use <code>DISTINCT</code>, for example: <code>count(DISTINCT role)</code>.</p>
</div>
<div class="paragraph">
<p>Aggregation works implicitly in Cypher.
We specify which result columns we wish to aggregate.
Cypher will use all non-aggregated columns as grouping keys.</p>
</div>
<div class="paragraph">
<p>Aggregation affects which data is still visible in ordering or later query parts.</p>
</div>
<div class="paragraph">
<p>The following statement finds out how often an actor and director have worked together:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">MATCH (actor:Person)-[:ACTED_IN]-&gt;(movie:Movie)&lt;-[:DIRECTED]-(director:Person)
RETURN actor, director, count(*) AS collaborations</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>+--------------------------------------------------------------------------------------------------------------+
| actor                                     | director                                        | collaborations |
+--------------------------------------------------------------------------------------------------------------+
| (:Person {name: "Tom Hanks", born: 1956}) | (:Person {name: "Robert Zemeckis", born: 1951}) | 1              |
+--------------------------------------------------------------------------------------------------------------+

1 row</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cypher-intro-results-ordering-and-pagination"><a class="anchor" href="#cypher-intro-results-ordering-and-pagination"></a>Ordering and pagination</h3>
<div class="paragraph">
<p>It is common to sort and paginate after aggregating using <code>count(x)</code>.</p>
</div>
<div class="paragraph">
<p>Ordering is done using the <code>ORDER BY expression [ASC|DESC]</code> clause.
The expression can be any expression, as long as it is computable from the returned information.</p>
</div>
<div class="paragraph">
<p>For instance, if we return <code>person.name</code> we can still <code>ORDER BY person.age</code> since both are accessible from the <code>person</code> reference.
We cannot order by things that are not returned.
This is especially important with aggregation and <code>DISTINCT</code> return values, since both remove the visibility of data that is aggregated.</p>
</div>
<div class="paragraph">
<p>Pagination is done using the <code>SKIP +{offset}+`and `LIMIT +{count}+</code> clauses.</p>
</div>
<div class="paragraph">
<p>A common pattern is to aggregate for a count (<em>score</em> or <em>frequency</em>), order by it, and only return the top-n entries.</p>
</div>
<div class="paragraph">
<p>For instance to find the most prolific actors we could do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">MATCH (a:Person)-[:ACTED_IN]-&gt;(m:Movie)
RETURN a, count(*) AS appearances
ORDER BY appearances DESC LIMIT 10;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>+---------------------------------------------------------+
| a                                         | appearances |
+---------------------------------------------------------+
| (:Person {name: "Tom Hanks", born: 1956}) | 2           |
+---------------------------------------------------------+

1 row</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cypher-intro-results-collecting-aggregation"><a class="anchor" href="#cypher-intro-results-collecting-aggregation"></a>Collecting aggregation</h3>
<div class="paragraph">
<p>A very helpful aggregation function is <code>collect()</code>, which collects all the aggregated values into a list.
This is very useful in many situations, since no information of details is lost while aggregating.</p>
</div>
<div class="paragraph">
<p><code>collect()</code> is well-suited for retrieving typical parent-child structures, where one core entity (<em>parent</em>, <em>root</em> or <em>head</em>) is returned per row with all its dependent information in associated lists created with <code>collect()</code>.
This means that there is no need to repeat the parent information for each child row, or running <code>n+1</code> statements to retrieve the parent and its children individually.</p>
</div>
<div class="paragraph">
<p>The following statement could be used to retrieve the cast of each movie in our database:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">MATCH (m:Movie)&lt;-[:ACTED_IN]-(a:Person)
RETURN m.title AS movie, collect(a.name) AS cast, count(*) AS actors</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>+-----------------------------------------+
| movie          | cast          | actors |
+-----------------------------------------+
| "Forrest Gump" | ["Tom Hanks"] | 1      |
| "Cloud Atlas"  | ["Tom Hanks"] | 1      |
+-----------------------------------------+

2 rows</pre>
</div>
</div>
<div class="paragraph">
<p>The lists created by <code>collect()</code> can either be used from the client consuming the Cypher results, or directly within a statement with any of the list functions or predicates.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cypher-intro-large-statements"><a class="anchor" href="#cypher-intro-large-statements"></a>Composing large statements</h2>
<div class="sectionbody">
<div class="quoteblock abstract">
<blockquote>
<div class="paragraph">
<p>This section describes how to compose large statements using the <code>UNION</code> and <code>WITH</code> keywords.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>This section includes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#cypher-intro-large-statements-example-graph">Example graph</a></p>
</li>
<li>
<p><a href="#cypher-intro-large-statements-union">UNION</a></p>
</li>
<li>
<p><a href="#cypher-intro-large-statements-with">WITH</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="cypher-intro-large-statements-example-graph"><a class="anchor" href="#cypher-intro-large-statements-example-graph"></a>Example graph</h3>
<div class="paragraph">
<p>We continue using the same example data as before:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">CREATE (matrix:Movie { title:"The Matrix",released:1997 })
CREATE (cloudAtlas:Movie { title:"Cloud Atlas",released:2012 })
CREATE (forrestGump:Movie { title:"Forrest Gump",released:1994 })
CREATE (keanu:Person { name:"Keanu Reeves", born:1964 })
CREATE (robert:Person { name:"Robert Zemeckis", born:1951 })
CREATE (tom:Person { name:"Tom Hanks", born:1956 })
CREATE (tom)-[:ACTED_IN { roles: ["Forrest"]}]-&gt;(forrestGump)
CREATE (tom)-[:ACTED_IN { roles: ['Zachry']}]-&gt;(cloudAtlas)
CREATE (robert)-[:DIRECTED]-&gt;(forrestGump)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the resulting graph:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  N0 [
    label = "{Movie|title = \'The Matrix\'\lreleased = 1997\l}"
  ]
  N1 [
    label = "{Movie|title = \'Cloud Atlas\'\lreleased = 2012\l}"
  ]
  N2 [
    label = "{Movie|title = \'Forrest Gump\'\lreleased = 1994\l}"
  ]
  N3 [
    label = "{Person|name = \'Keanu Reeves\'\lborn = 1964\l}"
  ]
  N4 [
    label = "{Person|name = \'Robert Zemeckis\'\lborn = 1951\l}"
  ]
  N4 -&gt; N2 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "DIRECTED\n"
  ]
  N5 [
    label = "{Person|name = \'Tom Hanks\'\lborn = 1956\l}"
  ]
  N5 -&gt; N1 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "ACTED_IN\nroles = \[\'Zachry\'\]\l"
  ]
  N5 -&gt; N2 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "ACTED_IN\nroles = \[\'Forrest\'\]\l"
  ]</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cypher-intro-large-statements-union"><a class="anchor" href="#cypher-intro-large-statements-union"></a>UNION</h3>
<div class="paragraph">
<p>If you want to combine the results of two statements that have the same result structure, you can use <code>UNION [ALL]</code>.</p>
</div>
<div class="paragraph">
<p>For example, the following statement lists both actors and directors:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">MATCH (actor:Person)-[r:ACTED_IN]-&gt;(movie:Movie)
RETURN actor.name AS name, type(r) AS type, movie.title AS title
UNION
MATCH (director:Person)-[r:DIRECTED]-&gt;(movie:Movie)
RETURN director.name AS name, type(r) AS type, movie.title AS title</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>+-------------------------------------------------+
| name              | type       | title          |
+-------------------------------------------------+
| "Tom Hanks"       | "ACTED_IN" | "Cloud Atlas"  |
| "Tom Hanks"       | "ACTED_IN" | "Forrest Gump" |
| "Robert Zemeckis" | "DIRECTED" | "Forrest Gump" |
+-------------------------------------------------+

3 rows</pre>
</div>
</div>
<div class="paragraph">
<p>Note that the returned columns must be aliased in the same way in all the sub-clauses.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The query above is equivalent to this more compact query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">MATCH (actor:Person)-[r:ACTED_IN|DIRECTED]-&gt;(movie:Movie)
RETURN actor.name AS name, type(r) AS type, movie.title AS title</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="cypher-intro-large-statements-with"><a class="anchor" href="#cypher-intro-large-statements-with"></a>WITH</h3>
<div class="paragraph">
<p>In Cypher it is possible to chain fragments of statements together, similar to how it is done within a data-flow pipeline.
Each fragment works on the output from the previous one, and its results can feed into the next one.
<em>Only</em> columns declared in the <code>WITH</code> clause are available in subsequent query parts.</p>
</div>
<div class="paragraph">
<p>The <code>WITH</code> clause is used to combine the individual parts and declare which data flows from one to the other.
<code>WITH</code> is similar to the <code>RETURN</code> clause.
The difference is that the <code>WITH</code> clause does not finish the query, but prepares the input for the next part.
Expressions, aggregations, ordering and pagination can be used in the same way as in the <code>RETURN</code> clause.
The only difference is all columns must be aliased.</p>
</div>
<div class="paragraph">
<p>In the example below, we collect the movies someone appeared in, and then filter out those which appear in only one movie:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">MATCH (person:Person)-[:ACTED_IN]-&gt;(m:Movie)
WITH person, count(*) AS appearances, collect(m.title) AS movies
WHERE appearances &gt; 1
RETURN person.name, appearances, movies</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>+-------------------------------------------------------------+
| person.name | appearances | movies                          |
+-------------------------------------------------------------+
| "Tom Hanks" | 2           | ["Cloud Atlas", "Forrest Gump"] |
+-------------------------------------------------------------+

1 row</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cypher-intro-schema"><a class="anchor" href="#cypher-intro-schema"></a>Defining a schema</h2>
<div class="sectionbody">
<div class="quoteblock abstract">
<blockquote>
<div class="paragraph">
<p>This section describes how to define and use indexes and constraints.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>This section includes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#cypher-intro-schema-example-graph">Example graph</a></p>
</li>
<li>
<p><a href="#cypher-intro-indexes">Defining and using indexes</a></p>
</li>
<li>
<p><a href="#cypher-intro-constraints">Defining and using constraints</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="cypher-intro-schema-example-graph"><a class="anchor" href="#cypher-intro-schema-example-graph"></a>Example graph</h3>
<div class="paragraph">
<p>First we create some data to use for our examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">CREATE (matrix:Movie { title:"The Matrix",released:1997 })
CREATE (cloudAtlas:Movie { title:"Cloud Atlas",released:2012 })
CREATE (forrestGump:Movie { title:"Forrest Gump",released:1994 })
CREATE (keanu:Person { name:"Keanu Reeves"})
CREATE (robert:Person { name:"Robert Zemeckis", born:1951 })
CREATE (tom:Person { name:"Tom Hanks", born:1956 })
CREATE (tom)-[:ACTED_IN { roles: ["Forrest"]}]-&gt;(forrestGump)
CREATE (tom)-[:ACTED_IN { roles: ['Zachry']}]-&gt;(cloudAtlas)
CREATE (robert)-[:DIRECTED]-&gt;(forrestGump)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the resulting graph:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  N0 [
    label = "{Movie|title = \'The Matrix\'\lreleased = 1997\l}"
  ]
  N1 [
    label = "{Movie|title = \'Cloud Atlas\'\lreleased = 2012\l}"
  ]
  N2 [
    label = "{Movie|title = \'Forrest Gump\'\lreleased = 1994\l}"
  ]
  N3 [
    label = "{Person|name = \'Keanu Reeves\'}"
  ]
  N4 [
    label = "{Person|name = \'Robert Zemeckis\'\lborn = 1951\l}"
  ]
  N4 -&gt; N2 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "DIRECTED\n"
  ]
  N5 [
    label = "{Person|name = \'Tom Hanks\'\lborn = 1956\l}"
  ]
  N5 -&gt; N1 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "ACTED_IN\nroles = \[\'Zachry\'\]\l"
  ]
  N5 -&gt; N2 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "ACTED_IN\nroles = \[\'Forrest\'\]\l"
  ]</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cypher-intro-indexes"><a class="anchor" href="#cypher-intro-indexes"></a>Using indexes</h3>
<div class="paragraph">
<p>The main reason for using indexes in a graph database is to find the starting point of a graph traversal.
Once that starting point is found, the traversal relies on in-graph structures to achieve high performance.</p>
</div>
<div class="paragraph">
<p>Indexes can be added at any time.
Note, however, that if there is existing data in the database, it will take some time for an index to come online.</p>
</div>
<div class="paragraph">
<p>In this case we want to create an index to speed up finding actors by name in the database:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">CREATE INDEX ON :Actor(name)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In most cases it is not necessary to specify indexes when querying for data, as the appropriate indexes will be used automatically.
For example, the following query will automatically use the index defined above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">MATCH (actor:Actor { name: "Tom Hanks" })
RETURN actor;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <em>composite index</em> is an index on multiple properties for all nodes that have a particular label.
For example, the following statement will create a composite index on all nodes labeled with <code>Actor</code> and which have both a <code>name</code> and a <code>born</code> property.
Note that since the node with the <code>Actor</code> label that has a <code>name</code> of "Keanu Reeves" does not have the <code>born</code> property.
Therefore that node will not be added to the index.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">CREATE INDEX ON :Actor(name, born)</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can inspect our database to find out what indexes are defined.
We do this by calling the built-in procedure <code>db.indexes</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">CALL db.indexes
YIELD description, tokenNames, properties, type;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>+---------------------------------------------------------------------------------------+
| description                   | tokenNames | properties       | type                  |
+---------------------------------------------------------------------------------------+
| "INDEX ON :Actor(name)"       | ["Actor"]  | ["name"]         | "node_label_property" |
| "INDEX ON :Actor(name, born)" | ["Actor"]  | ["name", "born"] | "node_label_property" |
+---------------------------------------------------------------------------------------+

2 rows</pre>
</div>
</div>
<div class="paragraph">
<p>Learn more about indexes in <a href="#cypher-manual.adoc#administration-indexes-fulltext-search" class="page unresolved">Cypher Manual &#8594; Indexes</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It is possible to specify which index to use in a particular query, using <em>index hints</em>.
This is one of several options for query tuning, described in detail in <a href="#cypher-manual.adoc#query-tuning" class="page unresolved">Cypher manual &#8594; Query tuning</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="cypher-intro-constraints"><a class="anchor" href="#cypher-intro-constraints"></a>Using constraints</h3>
<div class="paragraph">
<p>Constraints are used to make sure that the data adheres to the rules of the domain.
For example: "If a node has a label of <code>Actor</code> and a property of <code>name</code>, then the value of <code>name</code> must be unique among all nodes that have the <code>Actor</code> label".</p>
</div>
<div class="paragraph">
<p>To create a constraint that makes sure that our database will never contain more than one node with the label <code>Movie</code> and the property <code>title</code>, we use the IS UNIQUE syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.title IS UNIQUE</code></pre>
</div>
</div>
<div class="paragraph">
<p>Adding the unique constraint will implicitly add an index on that property.
If the constraint is dropped, but the index is still needed, the index will have to be created explicitly.</p>
</div>
<div class="paragraph">
<p>Constraints can be added to database that already has data in it.
This requires that the existing data complies with the constraint that is being added.</p>
</div>
<div class="paragraph">
<p>We can inspect our database to find out what constraints are defined.
We do this by calling the built-in procedure <code>db.constraints</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">CALL db.constraints</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>+--------------------------------------------------------------+
| description                                                  |
+--------------------------------------------------------------+
| "CONSTRAINT ON ( movie:Movie ) ASSERT movie.title IS UNIQUE" |
+--------------------------------------------------------------+

1 row</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The constraint described above is available for all editions of Neo4j.
Additional constraints are available for Neo4j Enterprise Edition.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Learn more about constraints in <a href="#cypher-manual.adoc#administration-constraints" class="page unresolved">Cypher manual &#8594; Constraints</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cypher-intro-load-csv"><a class="anchor" href="#cypher-intro-load-csv"></a>Import data</h2>
<div class="sectionbody">
<div class="quoteblock abstract">
<blockquote>
This tutorial will demonstrate how to import data from CSV files using <code>LOAD CSV</code>.
</blockquote>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For a full description of <code>LOAD CSV</code> , see <a href="#cypher-manual.adoc#query-load-csv" class="page unresolved">Cypher Manual &#8594; <code>LOAD CSV</code></a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>With <code>LOAD CSV</code> we can conveniently import data into Neo4j and have access to Cypher to perform actions on the data as desired.</p>
</div>
<div class="paragraph">
<p>In this example, we are given the following CSV files:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>persons.csv</em>, a list of persons:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>id,name
1,Charlie Sheen
2,Michael Douglas
3,Martin Sheen
4,Morgan Freeman</code></pre>
</div>
</div>
</li>
<li>
<p><em>movies.csv</em>, a list of movies:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>id,title,country,year
1,Wall Street,USA,1987
2,The American President,USA,1995
3,The Shawshank Redemption,USA,1994</code></pre>
</div>
</div>
</li>
<li>
<p><em>roles.csv</em>, a list of which role was played by some of these persons in each movie:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>personId,movieId,role
1,1,Bud Fox
4,1,Carl Fox
3,1,Gordon Gekko
4,2,A.J. MacInerney
3,2,President Andrew Shepherd
5,3,Ellis Boyd 'Red' Redding</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>By inspecting the files we can see that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Each person has a unique id and a name.</p>
</li>
<li>
<p>Each movie has a unique id, a title, a country where it was made, and a year when it was released.</p>
</li>
<li>
<p>Using the <em>roles</em> file we can deduct which person has acted in which movie, and what role(s) they played.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We can come up with the following simple data model:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  N0 [
    label = "{Movie|title = \'movie title\'\lyear = \'year released\'\l}"
  ]
  N3 [
    label = "{Person|name = \'name of person\'\l}"
  ]
  N8 [
    label = "{Country|name = \'name of country\'\l}"
  ]
  N3 -&gt; N0 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "PLAYED\nroles = \[\'role(s) played\'\]\l"
  ]
  N0 -&gt; N8 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "MADE_IN"
  ]</pre>
</div>
</div>
<div class="paragraph">
<p>Before starting our imports, we will prepare our database by creating indexes and constraints.
Since we expect the <code>id</code> property on <code>Person</code> and <code>Movie</code> to be unique in each set, we will create a unique constraint.
This protects us from invalid data since constraint creation will fail if there are multiple nodes with the same id property.</p>
</div>
<div class="paragraph">
<p>Creating a unique constraint also implicitly creates a unique index.
The <code>id</code> property is a temporary property used to look up the appropriate nodes for a relationship when importing the third file.
By indexing the <code>id</code> property, node lookup (e.g. by <code>MATCH</code>) will be much faster.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">CREATE CONSTRAINT ON (person:Person) ASSERT person.id IS UNIQUE</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.id IS UNIQUE</code></pre>
</div>
</div>
<div class="paragraph">
<p>Additionally, we create an index on the <code>name</code> property on <code>Country</code> nodes to ensure fast lookups:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">CREATE INDEX ON :Country(name)</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When using <code>MERGE</code> or <code>MATCH</code> with <code>LOAD CSV</code> we need to make sure we have an <a href="#cypher-intro-indexes">index</a> or a <a href="#cypher-intro-constraints">unique constraint</a> on the property that we are merging on.
This will ensure that the query executes in a performant way.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In this example, the CSV files are stored in the default import directory on the database server, and we can access them using a <code><a href="file:///" class="bare">file:///</a></code> URL.
Other locations are configurable, and additionally, <code>LOAD CSV</code> supports accessing CSV files via <code>HTTPS</code>, <code>HTTP</code>, and <code>FTP</code>.
For complete instructions, see <a href="#cypher-manual.adoc#query-load-csv" class="page unresolved">Cypher Manual &#8594; <code>LOAD CSV</code></a>.</p>
</div>
<div class="paragraph">
<p>Using the following Cypher queries, we will create a node for each person, a node for each movie and a relationship between the two with a property denoting the role.
We are also keeping track of the country in which each movie was made.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s start with importing the <em>persons.csv</em> file.
Here is the Cypher used to do the import:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">LOAD CSV WITH HEADERS FROM "file:///persons.csv" AS csvLine
CREATE (p:Person {id: toInteger(csvLine.id), name: csvLine.name})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, let&#8217;s import the movies.
This time, we are also creating a relationship to the country in which the movie was made.
We are using <code>MERGE</code> to create nodes that represent countries.
Using <code>MERGE</code> avoids creating duplicate country nodes in the case where multiple movies have been made in the same country.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">LOAD CSV WITH HEADERS FROM "file:///movies.csv" AS csvLine
MERGE (country:Country {name: csvLine.country})
CREATE (movie:Movie {id: toInteger(csvLine.id), title: csvLine.title, year:toInteger(csvLine.year)})
CREATE (movie)-[:MADE_IN]-&gt;(country)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, we will create relationships between the persons and the movies; one actor can participate in many movies, and one movie has many actors in it.
Now importing the relationships is a matter of finding the nodes and then creating relationships between them.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS FROM "file:///roles.csv" AS csvLine
MATCH (person:Person {id: toInteger(csvLine.personId)}),(movie:Movie {id: toInteger(csvLine.movieId)})
CREATE (person)-[:PLAYED {role: csvLine.role}]-&gt;(movie)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For larger data files, it is useful to use the hint <code>USING PERIODIC COMMIT</code> clause of <code>LOAD CSV</code>.
This hint tells Neo4j that the query might build up inordinate amounts of transaction state, and so needs to be periodically committed.
For more information, see <a href="#cypher-manual.adoc#query-using-periodic-commit-hint" class="page unresolved">cypher-manual.adoc#query-using-periodic-commit-hint</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally, since the <code>id</code> property was only necessary to import the relationships, we can drop the constraints and the <code>id</code> property from all movie and person nodes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">DROP CONSTRAINT ON (person:Person) ASSERT person.id IS UNIQUE</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">DROP CONSTRAINT ON (movie:Movie) ASSERT movie.id IS UNIQUE</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cypher hljs" data-lang="cypher">MATCH (n)
WHERE n:Person OR n:Movie
REMOVE n.id</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the resulting graph:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  N0 [
    label = "{Movie|title = \'Wall Street\'\lyear = 1987\l}"
  ]
  N1 [
    label = "{Movie|title = \'The Shawshank Redemption\'\lyear = 1994\l}"
  ]
  N2 [
    label = "{Movie|title = \'The American President\'\lyear = 1995\l}"
  ]
  N3 [
    label = "{Person|name = \'Martin Sheen\'\l}"
  ]
  N4 [
    label = "{Person|name = \'Charlie Sheen\'\l}"
  ]
  N6 [
    label = "{Person|name = \'Morgan Freeman\'\l}"
  ]
  N7 [
    label = "{Person|name = \'Michael Douglas\'\l}"
  ]
  N8 [
    label = "{Country|name = \'USA\'\l}"
  ]
  N4 -&gt; N0 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "PLAYED\nroles = \[\'Bud Fox\'\]\l"
  ]
  N3 -&gt; N0 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "PLAYED\nroles = \[\'Carl Fox\'\]\l"
  ]
  N7 -&gt; N0 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "PLAYED\nroles = \[\'Gordon Gekko\'\]\l"
  ]
  N7 -&gt; N2 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "PLAYED\nroles = \[\'President Andrew Shepherd\'\]\l"
  ]
  N3 -&gt; N2 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "PLAYED\nroles = \[\'A.J. MacInerney\'\]\l"
  ]
  N6 -&gt; N1 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "PLAYED\nroles = \[\'Ellis Boyd \'Red\' Redding\'\]\l"
  ]
  N0 -&gt; N8 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "MADE_IN"
  ]
  N1 -&gt; N8 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "MADE_IN"
  ]
  N2 -&gt; N8 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "MADE_IN"
  ]</pre>
</div>
</div>
</div>
</div>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<div class="feedback">
    <div class="header question">
        <p><strong>Was this page helpful?</strong></p>

        <svg width="22px" height="22px" viewBox="0 0 22 22" role="button" class="no">
            <path
                d="M6.25,15.8333333 C6.25,13.7622655 7.92893219,12.0833333 10,12.0833333 C12.0710678,12.0833333 13.75,13.7622655 13.75,15.8333333"
                id="Shape"></path>
            <circle id="Oval" cx="10" cy="10" r="9.58333333"></circle>
            <path
                d="M12.5,4.58333333 C12.8934466,4.05873783 13.5109223,3.75 14.1666667,3.75 C14.822411,3.75 15.4398867,4.05873783 15.8333333,4.58333333"
                id="Shape"></path>
            <line x1="4.58333333" y1="7.91666667" x2="7.08333333" y2="7.91666667" id="Shape"></line>
            <path
                d="M7.08333333,8.54166667 C6.96827401,8.54166667 6.875,8.44839266 6.875,8.33333333 C6.875,8.21827401 6.96827401,8.125 7.08333333,8.125 C7.19839266,8.125 7.29166667,8.21827401 7.29166667,8.33333333 C7.29166667,8.44839266 7.19839266,8.54166667 7.08333333,8.54166667"
                id="Shape"></path>
            <line x1="12.9166667" y1="7.91666667" x2="15.4166667" y2="7.91666667" id="Shape"></line>
            <path
                d="M15.4166667,8.54166667 C15.3016073,8.54166667 15.2083333,8.44839266 15.2083333,8.33333333 C15.2083333,8.21827401 15.3016073,8.125 15.4166667,8.125 C15.531726,8.125 15.625,8.21827401 15.625,8.33333333 C15.625,8.44839266 15.531726,8.54166667 15.4166667,8.54166667"
                id="Shape"></path>
            <path
                d="M4.16666667,4.58333333 C4.5601133,4.05873783 5.17758895,3.75 5.83333333,3.75 C6.48907772,3.75 7.10655337,4.05873783 7.5,4.58333333"
                id="Shape"></path>
        </svg>

        <svg width="22px" height="22px" viewBox="0 0 22 22" role="button" class="yes">
            <circle id="Oval" cx="10" cy="10" r="9.58333333"></circle>
            <path
                d="M5.41666667,8.125 C5.53172599,8.125 5.625,8.21827401 5.625,8.33333333 C5.625,8.44839266 5.53172599,8.54166667 5.41666667,8.54166667 C5.30160734,8.54166667 5.20833333,8.44839266 5.20833333,8.33333333 C5.20833333,8.21827401 5.30160734,8.125 5.41666667,8.125"
                id="Shape"></path>
            <path
                d="M14.5833333,8.125 C14.468274,8.125 14.375,8.21827401 14.375,8.33333333 C14.375,8.44839266 14.468274,8.54166667 14.5833333,8.54166667 C14.6983927,8.54166667 14.7916667,8.44839266 14.7916667,8.33333333 C14.7916667,8.21827401 14.6983927,8.125 14.5833333,8.125"
                id="Shape"></path>
            <path
                d="M13.2275,12.9166657 C13.4853075,12.9162808 13.7287776,13.035241 13.8869095,13.2388563 C14.0450415,13.4424715 14.1000278,13.7078123 14.0358333,13.9575 C13.562901,15.7999679 11.9021969,17.0882321 10,17.0882321 C8.09780311,17.0882321 6.43709903,15.7999679 5.96416667,13.9575 C5.89997223,13.7078123 5.95495852,13.4424715 6.11309045,13.2388563 C6.27122239,13.035241 6.51469246,12.9162808 6.7725,12.9166657 L13.2275,12.9166657 Z"
                id="Shape"></path>
        </svg>
    </div>


</div>  </div>
</main>
</div>
<footer class="footer">
  <div class="column">
    <div class="logo-footer"></div>
    <p> <span id="footer-copyright-year">2020</span> Neo4j, Inc.<br>
      <a href="/terms/">Terms</a> | <a href="/privacy-policy/">Privacy </a> | <a href="/sitemap/">Sitemap</a></p>
    <p>Neo4j<sup></sup>, Neo Technology<sup></sup>, Cypher<sup></sup>, Neo4j<sup></sup> Bloom<sup></sup> and
      Neo4j<sup></sup> Aura<sup></sup> are registered trademarks
      of Neo4j, Inc. All other marks are owned by their respective companies.</p>
  </div>

  <div class="column">
    <a href="/contact-us?ref=footer">Contact Us </a>
    <p>US: 1-855-636-4532<br>
      Sweden +46 171 480 113<br>
      UK: +44 20 3868 3223<br>
      France: +33 (0) 8 05 08 03 44<br>
      <!--Germany: +49 (0)89 26204 6300</p>-->
    </p>
  </div>
</footer><script src="https://d3js.org/d3-dispatch.v1.min.js"></script>
<script src="https://d3js.org/d3-quadtree.v1.min.js"></script>
<script src="https://d3js.org/d3-timer.v1.min.js"></script>
<script src="https://d3js.org/d3-force.v2.min.js"></script>

<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/gram.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
<script async src="../../../_/js/vendor/search.js"></script>  </body>
</html>
